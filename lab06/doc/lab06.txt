lab06
	Лабораторна робота №6. Масиви
	Ворона Данило Олексійович, КН-923в

1. Вибрав завдання (**) Перетворити число (максимальне значення якого - 9999) в рядок. (усі символи
нижнього регістру на виході). Наприклад,
• 123 – “one hundred twenty three”,
• 4311 – “four thousands three hundreds eleven”

2. Написав програму яка перетворює цифрове число в буквене, використовуючи остачу від ділення на 10.

3. Використав бібліотеку <stdio.h>, щоб виконати функцію scanf, яка зчитує введені дані.

4. Присвоїв 11 змінних з яких:
first - щоб зберігати першу цифру числа (а саме тисячі)

second - щоб зберігати другу цифру числа (сотні)

third_tens - щоб зберігати третю цифру числа (десятки)

third_doubles - щоб зберігати подвійні числа (11,12,13...19)	

fourth - щоб зберігати четверту цифру числа (одиниці)	

remain_for_doubles - остача, яка використовується, щоб обчислити наявність подвійних чисел	

remain - остача, яка використовується щоб розподілити номери перши чотирьох чисел і
зіставити їх з тими, що записані у масиві.

input - змінна для введення числа.

*single[] - вказівник на масив одиниць.

*doubles[] - вказівник на масив подвійних чисел.

*tens[] - вказівник на масив десятків.

5. Працює програма за наступним принципом:

1) Отримується значення від 0 до 9999, якщо число більше, програма завершується

2) Введене число розкидується по циклам відповідно більше 1000, більше 100, більше 10, більше 0,
це створено, для того, щоб наприклад у змінну first не попадала цифра, що має бути в second
якщо число менше 1000

3) Якщо число більше 0, воно ділиться на 10, знаходиться остача (remain) яка
потім буде використана перемінними first, second, third_doubles, third_tens, fourth,
якщо число після всіх операцій менше 0, цикл завершується, бо всі остачі знайдено

4) Щоб перевірити чи є в числі подвійні цифри, візьмемо остачу від ділення на 100,
вона має бути в межах від 11 до 19

5) Якщо ж їх немає то перемінна в межах якої знаходиться число забирає значення остачі і
в кінці циклу ділиться на 10, щоб продовжити його
Наприклад 9876, перемінна fourth набуде значення 6, second - 7, third_tens - 8, first - 9,
в числі 9511 third_tens не буде, замість неї - third doubles.

6) Далі все дуже просто - кожне число символізує позицію слова в масиві, для цього спеціально
на початку додали пусті значення в кожний масив, щоб він починався з 1

7) І на останок щоб викликати потрібне слово вказуємо поінтером на масив, і номер слова в ньому
Наприклад: tens[third_tens], викличе слово номер якого зберігається в змінній third_tens.

6. В кінці додаємо умови до принту слів і розрядність(тисячі, сотні)

7. Перевірка у відладчику:

1) На початку всі значення нульові:
(int) first = 0
(int) second = 0
(int) third_tens = 0
(int) third_doubles = 0
(int) fourth = 0
(int) remain_for_doubles = 0
(int) remain = 0
(int) input = 0
(char *[10]) single = ([0] = "", [1] = "one", [2] = "two", [3] = "three", [4] = "four", [5] = "five", [6] = "six", [7] = "seven", [8] = "eight", [9] = "nine")
(char *[10]) doubles = ([0] = "", [1] = "eleven", [2] = "twelve", [3] = "thirteen", [4] = "fourteen", [5] = "fifteen", [6] = "sixteen", [7] = "seventeen", [8] = "eighteen", [9] = "nineteen")
(char *[10]) tens = ([0] = "", [1] = "ten", [2] = "twenty", [3] = "thirty", [4] = "fourty", [5] = "fifty", [6] = "sixty", [7] = "seventy", [8] = "eighty", [9] = "ninety")

2) Після першого циклу для 4-значних чисел, ввівши 2546 маємо таке:
(int) first = 2
(int) second = 5
(int) third_tens = 4
(int) third_doubles = 0
(int) fourth = 6
(int) remain_for_doubles = 2
(int) remain = 2
(int) input = 0

3) Для другого циклу 3-значних чисел результат 423:
(int) first = 0
(int) second = 4
(int) third_tens = 6
(int) third_doubles = 0
(int) fourth = 2
(int) remain_for_doubles = 4
(int) remain = 4
(int) input = 0

3) Для третього 34:
(int) first = 0
(int) second = 0
(int) third_tens = 3
(int) third_doubles = 0
(int) fourth = 4
(int) remain_for_doubles = 3
(int) remain = 3
(int) input = 0

4) Для четвертого 5:
(int) first = 0
(int) second = 0
(int) third_tens = 0
(int) third_doubles = 0
(int) fourth = 5
(int) remain_for_doubles = 0
(int) remain = 5
(int) input = 0

8. Перевірка remain_for_doubles майже завжди вираховується, але використовується тільки у випадках,
коли число має в кінці 11,12,13...

9. Також спробував спростити програму циклами, але не довів до кінця:

for (int i = 0; i <= input; i++)	{
	if (input >= 11 && num_four == 0 && (input % 100 <= 19 && input % 100 >= 11)) {
			num_three_doubles = input % 10;
			input = input/10;
}	else if (input >= 1 && num_four == 0) {
			num_four = input % 10;
}	else if (input >= 1 && num_three_tens == 0) {
			num_three_tens = input % 10;
}	else if (input >= 1 && num_two == 0) {
			num_two = input % 10;
}	else	{
			num_one = input % 10;
}
			input = input/10;
			i = 0;
}
